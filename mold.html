<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Google Sheets CSV Demo</title>
</head>
<body>
<h1>Google Sheets CSV Fetch Demo</h1>
<p>Records found: <span id="count">0</span></p>
<table border="1" id="dataTable">
  <thead>
    <tr>
      <th>Timestamp</th>
      <th>Temp_004</th>
      <th>RH_004</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
/*
 * STEP 1: PUBLISH YOUR SHEET AS A CSV
 *   - In Google Sheets: File -> Publish to the web
 *   - Choose "Entire Document" or a specific sheet
 *   - Under 'Link', pick 'Comma-separated values (.csv)'
 *   - Copy the generated link
 *
 * STEP 2: REPLACE the CSV_URL below with your published link
*/
const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTtyaaD9UIdtuhO9BW1q6Mb4-26_jsidDU73HB1DE4Y8FE1tKSQxIAkLasrc3bT-0mvDy4ejjgTPJm1/pub?gid=0&single=true&output=csv';

// Our code expects these column headers exactly in row 1
const COL_TIMESTAMP = 'Timestamp';
const COL_TEMP = 'Temp_004';
const COL_RH = 'RH_004';

// We’ll store each row’s data here
const parsedData = [];

fetch(CSV_URL)
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not OK: ' + response.statusText);
    }
    return response.text();
  })
  .then(csv => {
    parseCsv(csv);
    displayData();
  })
  .catch(err => console.error('Fetch error:', err));

function parseCsv(csvText) {
  const lines = csvText.split('\n').map(line => line.trim()).filter(line => line);
  if (!lines.length) {
    console.warn('No lines in CSV');
    return;
  }

  // First line = headers
  const headers = lines[0].split(',');
  console.log('Headers =>', headers);

  const idxTimestamp = headers.indexOf(COL_TIMESTAMP);
  const idxTemp = headers.indexOf(COL_TEMP);
  const idxRh = headers.indexOf(COL_RH);

  // If any index is -1 => mismatch
  if (idxTimestamp === -1 || idxTemp === -1 || idxRh === -1) {
    console.warn('Could not find the expected columns. Make sure your CSV has EXACT headers:', 
      COL_TIMESTAMP, COL_TEMP, COL_RH
    );
    return;
  }

  // Process subsequent lines
  for (let i = 1; i < lines.length; i++) {
    const row = lines[i].split(',');
    if (row.length < headers.length) continue; // skip partial lines

    // Extract the data
    const ts = row[idxTimestamp];
    const tmpVal = row[idxTemp];
    const rhVal = row[idxRh];

    // Optional parse floats
    const tempFloat = parseFloat(tmpVal);
    const rhFloat = parseFloat(rhVal);

    // Debug print each row
    console.log(`Row #${i}`, { ts, tempFloat, rhFloat });

    // Store in an object
    parsedData.push({
      timestamp: ts,
      temperature: isNaN(tempFloat) ? null : tempFloat,
      humidity: isNaN(rhFloat) ? null : rhFloat
    });
  }
}

function displayData() {
  // Show record count
  document.getElementById('count').textContent = parsedData.length;

  const tbody = document.getElementById('dataTable').querySelector('tbody');
  // Clear old rows if any
  tbody.innerHTML = '';

  // Populate table
  parsedData.forEach((item, idx) => {
    const tr = document.createElement('tr');

    const tdTs = document.createElement('td');
    tdTs.textContent = item.timestamp || '';
    tr.appendChild(tdTs);

    const tdTemp = document.createElement('td');
    tdTemp.textContent = (item.temperature !== null) ? item.temperature : '';
    tr.appendChild(tdTemp);

    const tdRh = document.createElement('td');
    tdRh.textContent = (item.humidity !== null) ? item.humidity : '';
    tr.appendChild(tdRh);

    tbody.appendChild(tr);
  });
}
</script>
</body>
</html>
